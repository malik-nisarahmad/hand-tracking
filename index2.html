<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking Cursor Control</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            position: relative;
            max-width: 900px;
            width: 100%;
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
        }

        .cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ff4757, #ff3742);
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 20px rgba(255, 71, 87, 0.6), 0 0 40px rgba(255, 71, 87, 0.4);
            transition: all 0.1s ease;
            pointer-events: none;
            z-index: 10;
            display: none;
        }

        .cursor.active {
            display: block;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { 
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 71, 87, 0.6), 0 0 40px rgba(255, 71, 87, 0.4);
            }
            50% { 
                transform: scale(1.3);
                box-shadow: 0 0 30px rgba(255, 71, 87, 0.8), 0 0 60px rgba(255, 71, 87, 0.6);
            }
            100% { 
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 71, 87, 0.6), 0 0 40px rgba(255, 71, 87, 0.4);
            }
        }

        .controls {
            padding: 30px;
            background: white;
        }

        .status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            min-width: 120px;
        }

        .status-value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .status-label {
            font-size: 0.9rem;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hand-info {
            background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }

        .hand-info h3 {
            color: #1976d2;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .coordinates {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .coord-item {
            background: white;
            padding: 12px 15px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
        }

        .coord-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .coord-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .coordinates {
                grid-template-columns: 1fr;
            }
            
            .status {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üñêÔ∏è Advanced Hand Tracking Cursor</h1>
        <p>Move your hand to control the glowing cursor ‚Ä¢ AI-powered gesture recognition</p>
    </div>

    <div class="container">
        <div class="video-container">
            <video id="video" autoplay muted playsinline></video>
            <canvas id="canvas"></canvas>
            <div class="cursor" id="cursor"></div>
            <div class="loading" id="loading">
                <div class="loading-spinner"></div>
                <p>Initializing AI hand tracking...</p>
            </div>
        </div>

        <div class="controls">
            <div class="status">
                <div class="status-item">
                    <div class="status-value" id="handsCount">0</div>
                    <div class="status-label">Hands Detected</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="fps">0</div>
                    <div class="status-label">FPS</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="confidence">0%</div>
                    <div class="status-label">Confidence</div>
                </div>
            </div>

            <div class="hand-info" id="handInfo" style="display: none;">
                <h3>üëÜ Real-time Hand Position</h3>
                <div class="coordinates">
                    <div class="coord-item">
                        <div class="coord-label">Hand Center X</div>
                        <div class="coord-value" id="coordX">0</div>
                    </div>
                    <div class="coord-item">
                        <div class="coord-label">Hand Center Y</div>
                        <div class="coord-value" id="coordY">0</div>
                    </div>
                    <div class="coord-item">
                        <div class="coord-label">Cursor X</div>
                        <div class="coord-value" id="cursorX">0</div>
                    </div>
                    <div class="coord-item">
                        <div class="coord-label">Cursor Y</div>
                        <div class="coord-value" id="cursorY">0</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class HandTracker {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.cursor = document.getElementById('cursor');
                this.loading = document.getElementById('loading');
                
                this.hands = null;
                this.camera = null;
                this.isInitialized = false;
                
                // Performance tracking
                this.frameCount = 0;
                this.lastTime = Date.now();
                
                // Smoothing for cursor movement
                this.smoothFactor = 0.3;
                this.lastCursorX = 0;
                this.lastCursorY = 0;
                
                this.init();
            }

            async init() {
                try {
                    await this.setupCamera();
                    await this.setupHandTracking();
                    this.loading.style.display = 'none';
                    this.isInitialized = true;
                } catch (error) {
                    this.showError('Failed to initialize: ' + error.message);
                }
            }

            async setupCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: 'user'
                        }
                    });
                    
                    this.video.srcObject = stream;
                    
                    return new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            this.video.play();
                            this.resizeCanvas();
                            resolve();
                        };
                    });
                } catch (error) {
                    throw new Error('Camera access denied. Please allow camera permissions.');
                }
            }

            async setupHandTracking() {
                return new Promise((resolve, reject) => {
                    try {
                        this.hands = new Hands({
                            locateFile: (file) => {
                                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                            }
                        });

                        this.hands.setOptions({
                            maxNumHands: 2,
                            modelComplexity: 1,
                            minDetectionConfidence: 0.7,
                            minTrackingConfidence: 0.5
                        });

                        this.hands.onResults((results) => {
                            this.onHandResults(results);
                        });

                        this.camera = new Camera(this.video, {
                            onFrame: async () => {
                                await this.hands.send({ image: this.video });
                            },
                            width: 1280,
                            height: 720
                        });
                        
                        this.camera.start();
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            resizeCanvas() {
                const rect = this.video.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            onHandResults(results) {
                this.updateFPS();
                this.clearCanvas();
                
                const handsCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
                document.getElementById('handsCount').textContent = handsCount;

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    // Draw each detected hand
                    results.multiHandLandmarks.forEach((handLandmarks, index) => {
                        this.drawHandWithRectangle(handLandmarks, index);
                    });
                    
                    // Use the first hand for cursor control
                    this.updateCursor(results.multiHandLandmarks[0]);
                    this.showHandInfo(true);
                    
                    // Calculate average confidence
                    const avgConfidence = Math.round(
                        results.multiHandLandmarks[0].reduce((sum, landmark) => 
                            sum + (landmark.visibility || 0.8), 0) / 21 * 100
                    );
                    document.getElementById('confidence').textContent = avgConfidence + '%';
                } else {
                    this.hideCursor();
                    this.showHandInfo(false);
                    document.getElementById('confidence').textContent = '0%';
                }
            }

            drawHandWithRectangle(handLandmarks, handIndex) {
                // Calculate bounding box for the hand
                let minX = 1, minY = 1, maxX = 0, maxY = 0;
                
                handLandmarks.forEach(landmark => {
                    minX = Math.min(minX, landmark.x);
                    minY = Math.min(minY, landmark.y);
                    maxX = Math.max(maxX, landmark.x);
                    maxY = Math.max(maxY, landmark.y);
                });

                // Add padding to the bounding box
                const padding = 0.05;
                minX = Math.max(0, minX - padding);
                minY = Math.max(0, minY - padding);
                maxX = Math.min(1, maxX + padding);
                maxY = Math.min(1, maxY + padding);

                // Convert to canvas coordinates
                const rectX = minX * this.canvas.width;
                const rectY = minY * this.canvas.height;
                const rectWidth = (maxX - minX) * this.canvas.width;
                const rectHeight = (maxY - minY) * this.canvas.height;

                // Draw animated rectangle around hand
                this.ctx.strokeStyle = `hsl(${handIndex * 60 + (Date.now() / 10) % 360}, 70%, 50%)`;
                this.ctx.lineWidth = 4;
                this.ctx.setLineDash([10, 5]);
                this.ctx.lineDashOffset = -(Date.now() / 50) % 15;
                
                // Add glow effect
                this.ctx.shadowColor = this.ctx.strokeStyle;
                this.ctx.shadowBlur = 10;
                
                this.ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
                
                // Reset shadow
                this.ctx.shadowBlur = 0;
                this.ctx.setLineDash([]);

                // Draw hand landmarks and connections
                this.drawHandLandmarks(handLandmarks, handIndex);

                // Draw hand label
                this.ctx.fillStyle = this.ctx.strokeStyle;
                this.ctx.font = 'bold 16px Arial';
                this.ctx.fillText(`Hand ${handIndex + 1}`, rectX, rectY - 10);
            }

            drawHandLandmarks(handLandmarks, handIndex) {
                // Hand connections (MediaPipe hand model)
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4],      // Thumb
                    [0, 5], [5, 6], [6, 7], [7, 8],      // Index finger
                    [0, 9], [9, 10], [10, 11], [11, 12], // Middle finger
                    [0, 13], [13, 14], [14, 15], [15, 16], // Ring finger
                    [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
                    [5, 9], [9, 13], [13, 17]             // Palm connections
                ];

                // Draw connections
                this.ctx.strokeStyle = `hsla(${handIndex * 60 + 120}, 60%, 45%, 0.8)`;
                this.ctx.lineWidth = 2;
                
                connections.forEach(([start, end]) => {
                    const startPoint = handLandmarks[start];
                    const endPoint = handLandmarks[end];
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(
                        startPoint.x * this.canvas.width,
                        startPoint.y * this.canvas.height
                    );
                    this.ctx.lineTo(
                        endPoint.x * this.canvas.width,
                        endPoint.y * this.canvas.height
                    );
                    this.ctx.stroke();
                });

                // Draw landmarks
                handLandmarks.forEach((landmark, index) => {
                    const x = landmark.x * this.canvas.width;
                    const y = landmark.y * this.canvas.height;
                    
                    // Different colors for different finger parts
                    let color;
                    if (index === 0) color = '#ff6b6b'; // Wrist
                    else if (index <= 4) color = '#4ecdc4'; // Thumb
                    else if (index <= 8) color = '#45b7d1'; // Index
                    else if (index <= 12) color = '#96ceb4'; // Middle
                    else if (index <= 16) color = '#feca57'; // Ring
                    else color = '#ff9ff3'; // Pinky
                    
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, index === 8 ? 8 : 5, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Add white border
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
            }

            updateCursor(handLandmarks) {
                // Use the center of the hand (wrist) for cursor position
                const wrist = handLandmarks[0];
                const middle_mcp = handLandmarks[9];
                
                // Calculate hand center
                const centerX = (wrist.x + middle_mcp.x) / 2;
                const centerY = (wrist.y + middle_mcp.y) / 2;
                
                if (centerX && centerY) {
                    const videoRect = this.video.getBoundingClientRect();
                    
                    // Convert normalized coordinates to pixel coordinates
                    const targetX = (1 - centerX) * videoRect.width; // Flip X for mirror effect
                    const targetY = centerY * videoRect.height;
                    
                    // Apply smoothing
                    const smoothX = this.lastCursorX + (targetX - this.lastCursorX) * this.smoothFactor;
                    const smoothY = this.lastCursorY + (targetY - this.lastCursorY) * this.smoothFactor;
                    
                    this.lastCursorX = smoothX;
                    this.lastCursorY = smoothY;
                    
                    // Position cursor
                    this.cursor.style.left = (smoothX - 10) + 'px';
                    this.cursor.style.top = (smoothY - 10) + 'px';
                    this.cursor.classList.add('active');
                    
                    // Update coordinate display
                    document.getElementById('coordX').textContent = Math.round(centerX * 1000) / 1000;
                    document.getElementById('coordY').textContent = Math.round(centerY * 1000) / 1000;
                    document.getElementById('cursorX').textContent = Math.round(smoothX);
                    document.getElementById('cursorY').textContent = Math.round(smoothY);
                }
            }

            hideCursor() {
                this.cursor.classList.remove('active');
            }

            showHandInfo(show) {
                document.getElementById('handInfo').style.display = show ? 'block' : 'none';
            }

            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            updateFPS() {
                this.frameCount++;
                const now = Date.now();
                
                if (now - this.lastTime >= 1000) {
                    const fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
                    document.getElementById('fps').textContent = fps;
                    this.frameCount = 0;
                    this.lastTime = now;
                }
            }

            showError(message) {
                this.loading.innerHTML = `
                    <div class="error">
                        <h3>‚ö†Ô∏è Error</h3>
                        <p>${message}</p>
                        <p>Please ensure you have a webcam and grant camera permissions.</p>
                        <button onclick="location.reload()" style="margin-top: 10px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Try Again
                        </button>
                    </div>
                `;
            }
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            new HandTracker();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            const video = document.getElementById('video');
            const canvas = document.getElementById('canvas');
            
            if (video && canvas) {
                const rect = video.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            }
        });
    </script>
</body>
</html>